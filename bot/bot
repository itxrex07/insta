import { IgApiClient } from 'instagram-private-api';
import { logger, fileUtils } from '../utils.js';
import { config } from '../config.js';

export class InstagramBot {
  constructor() {
    this.ig = new IgApiClient();
    this.messageHandlers = [];
    this.mediaHandlers = [];
    this.sessionPath = config.instagram.sessionPath;
    this.isRunning = false;
  }

  async login() {
    try {
      // Load existing session if available
      await this.loadSession();
      
      this.ig.state.generateDevice(config.instagram.username);
      
      // Try to login with existing session first
      try {
        await this.ig.account.currentUser();
        logger.info('âœ… Logged in with existing session');
        this.startMessageListener();
        return;
      } catch (error) {
        logger.info('ðŸ”„ Existing session invalid, logging in with credentials...');
      }

      // Login with username and password
      await this.ig.account.login(
        config.instagram.username,
        config.instagram.password
      );
      
      // Save session
      await this.saveSession();
      
      logger.info('âœ… Successfully logged into Instagram');
      
      // Start listening for messages
      this.startMessageListener();
      
    } catch (error) {
      logger.error('âŒ Instagram login failed:', error.message);
      throw error;
    }
  }

  async loadSession() {
    try {
      if (await fileUtils.pathExists(this.sessionPath)) {
        const sessionData = await fileUtils.readJson(this.sessionPath);
        if (sessionData) {
          await this.ig.state.deserialize(sessionData);
          logger.info('ðŸ“± Loaded Instagram session');
        }
      }
    } catch (error) {
      logger.warn('âš ï¸ Could not load session:', error.message);
    }
  }

  async saveSession() {
    try {
      const serialized = await this.ig.state.serialize();
      delete serialized.constants;
      await fileUtils.writeJson(this.sessionPath, serialized);
      logger.info('ðŸ’¾ Instagram session saved');
    } catch (error) {
      logger.warn('âš ï¸ Could not save session:', error.message);
    }
  }

  startMessageListener() {
    if (this.isRunning) return;
    
    this.isRunning = true;
    logger.info('ðŸ‘‚ Started message listener');
    
    // Check for messages periodically
    setInterval(async () => {
      if (this.isRunning) {
        try {
          await this.checkForNewMessages();
        } catch (error) {
          logger.error('Error checking messages:', error);
        }
      }
    }, config.instagram.messageCheckInterval);
  }

  async checkForNewMessages() {
    try {
      const inbox = await this.ig.feed.directInbox().items();
      
      for (const thread of inbox) {
        const messages = await this.ig.feed.directThread({
          thread_id: thread.thread_id
        }).items();
        
        // Only check the latest message
        for (const message of messages.slice(0, 1)) {
          if (this.isNewMessage(message)) {
            await this.handleMessage(message, thread);
          }
        }
      }
    } catch (error) {
      logger.error('Error fetching messages:', error);
    }
  }

  isNewMessage(message) {
    // Simple check - in production, you'd track processed message IDs
    const messageAge = Date.now() - (message.timestamp / 1000);
    return messageAge < 10000; // Messages newer than 10 seconds
  }

  async handleMessage(message, thread) {
    const processedMessage = {
      id: message.item_id,
      text: message.text || '',
      sender: message.user_id,
      senderUsername: thread.users.find(u => u.pk === message.user_id)?.username || 'Unknown',
      timestamp: new Date(message.timestamp / 1000),
      threadId: thread.thread_id,
      threadTitle: thread.thread_title || 'Direct Message',
      type: message.item_type,
      shouldForward: true
    };

    // Handle media messages
    if (message.media) {
      processedMessage.media = {
        type: message.media.media_type === 1 ? 'photo' : 'video',
        url: message.media.image_versions2?.candidates?.[0]?.url || 
             message.media.video_versions?.[0]?.url
      };
      
      // Notify media handlers
      for (const handler of this.mediaHandlers) {
        await handler(processedMessage);
      }
    }

    // Notify message handlers
    for (const handler of this.messageHandlers) {
      await handler(processedMessage);
    }
  }

  onMessage(handler) {
    this.messageHandlers.push(handler);
  }

  onMedia(handler) {
    this.mediaHandlers.push(handler);
  }

  async sendMessage(threadId, text) {
    try {
      await this.ig.entity.directThread(threadId).broadcastText(text);
      logger.info(`ðŸ“¤ Sent message to thread ${threadId}`);
    } catch (error) {
      logger.error('Error sending message:', error);
    }
  }

  async disconnect() {
    logger.info('ðŸ”Œ Disconnecting from Instagram...');
    this.isRunning = false;
    await this.saveSession();
  }
}
